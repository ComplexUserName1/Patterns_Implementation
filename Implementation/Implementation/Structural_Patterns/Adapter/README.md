**Название и классификация паттерна﻿**
 
﻿**Адаптер﻿** — паттерн, структурирующий классы и объекты.
 
﻿**Назначение﻿**
 
Преобразует интерфейс одного класса в другой интерфейс, на который рассчитаны клиенты. Адаптер обеспечивает совместную работу классов с несовместимыми интерфейсами, которая без него была бы невозможна.

﻿**Другие названия﻿**
 
Wrapper (обертка).

﻿**Применимость﻿**

Основные условия для применения паттерна адаптер:
* вы хотите использовать существующий класс, но его интерфейс не соответствует вашим потребностям;
* требуется создать повторно используемый класс, который должен взаимодействовать с заранее неизвестными или не связанными с ним классами, имеющими несовместимые интерфейсы;
* (только для адаптера объектов!) нужно использовать несколько существующих подклассов, но непрактично адаптировать их интерфейсы путем порождения новых подклассов от каждого. В этом случае адаптер объектов может приспосабливать интерфейс их общего родительского класса.

﻿**Отношения﻿**

Клиенты вызывают операции экземпляра адаптера Adapter. В свою очередь адаптер вызывает операции адаптируемого объекта или класса Adaptee, который и выполняет запрос.

﻿**Результаты﻿**
 
Адаптеры объектов и классов обладают разными достоинствами и недостатками. Адаптер класса:
* адаптирует Adaptee к Target, перепоручая действия конкретному классу Adaptee. Поэтому данный паттерн не будет работать, если мы захотим одновременно адаптировать класс и его подклассы;
позволяет адаптеру Adapter заместить некоторые операции адаптируемого класса Adaptee, так как Adapter есть не что иное, как подкласс Adaptee;
* вводит только один новый объект. Чтобы добраться до адаптируемого класса, не нужно никакого дополнительного обращения по указателю.

Адаптер объектов:

* позволяет одному адаптеру Adapter работать со многим адаптируемыми объектами Adaptee, то есть с самим Adaptee и его подклассами (если таковые имеются). Адаптер может добавить новую функциональность сразу всем адаптируемым объектам;
* затрудняет замещение операций класса Adaptee. Для этого потребуется породить от Adaptee подкласс и заставить Adapter ссылаться на этот подкласс, а не на сам Adaptee.

Ниже перечислены другие аспекты, которые следует рассмотреть, принимая решение о применении паттерна адаптер:
* объем работы по адаптации. Адаптеры сильно отличаются по объему работы, необходимой для адаптации интерфейса Adaptee к интерфейсу Target. Это может быть как простейшее преобразование (например, изменение имен операций), так и поддержка совершенно другого набора операций. Объем работы зависит от того, насколько сильно отличаются друг от друга интерфейсы целевого и адаптируемого классов;
* сменные адаптеры. Степень повторной используемости класса тем выше, чем меньше предположений делается о тех классах, которые будут его применять. Встраивая адаптацию интерфейса в класс, вы снимаете предположение о том, что другие классы должны «видеть» тот же интерфейс. Другими словами, адаптация интерфейса позволяет включить ваш класс в существующие системы, которые спроектированы для класса с другим интерфейсом. В системе ObjectWorks\Smalltalk [Par90] используется термин сменный адаптер (pluggable adapter) для обозначения классов со встроенной адаптацией интерфейса.
Рассмотрим виджет TreeDisplay, позволяющий графически отображать древовидные структуры. Если бы это был специализированный виджет, предназначенный только для одного приложения, то мы могли бы потребовать специального интерфейса от объектов, которые он отображает (например, чтобы все они происходили от абстрактного класса Tree). Но если мы хотим сделать его повторно используемым (например, частью библиотеки полезных виджетов), то устанавливать такое требование не
разумно. Скорее всего, разные приложения будут определять собственные классы для представления древовидных структур, и не следует заставлять их пользоваться именно нашим абстрактным классом Tree. А у разных структур деревьев будут и разные интерфейсы.
Например, в иерархии каталогов добраться до потомков удастся с помощью операции GetSubdirectories, тогда как для иерархии наследования соответствующая операция может называться GetSubclasses. Повторно используемый виджет TreeDisplay должен «уметь» отображать иерархии обоих видов, даже если у них разные интерфейсы. Другими словами, в TreeDisplay должна быть встроена возможность адаптации интерфейсов.
О способах встраивания адаптации интерфейсов в классы говорится в разделе «Реализация»;
* использование двусторонних адаптеров для обеспечения прозрачности. Потенциальный недостаток адаптеров заключается в том, что они непрозрачны для всех клиентов. Адаптированный объект уже не обладает интерфейсом Adaptee, так что его нельзя использовать там, где Adaptee был применим. Двусторонние адаптеры способны обеспечить такую прозрачность. А конкретнее, они полезны в тех случаях, когда разные клиенты должны видеть объект по-разному.
Рассмотрим двусторонний адаптер, который интегрирует каркас графических редакторов Unidraw [VL90] и библиотеку для разрешения ограничений QOCA [HHMV92]. В обеих системах есть классы, явно представляющие переменные: в Unidraw это StateVariable, а в QOCA — ConstraintVariable. Чтобы заставить Unidraw работать совместно с QOCA, ConstraintVariable нужно адаптировать к StateVariable. А для того чтобы решения QOCA распространялись на Unidraw, StateVariable следует адаптировать к ConstraintVariable.![image](https://github.com/user-attachments/assets/178d9176-9796-4281-afb2-1bfb99ff07f6)

Здесь применен двусторонний адаптер класса ConstraintStateVariable, который является подклассом одновременно StateVariable и ConstraintVariable и адаптирует оба интерфейса друг к другу. Множественное наследование в данном случае вполне приемлемо, поскольку интерфейсы адаптированных классов существенно различаются. Двусторонний адаптер класса соответствует интерфейсам каждого из адаптируемых классов и может работать в любой системе.
