**Название и классификация паттерна﻿**
 
﻿**Мост﻿** — паттерн, структурирующий объекты.
 
﻿**Назначение﻿**
 
Отделить абстракцию от ее реализации так, чтобы то и другое можно было изменять независимо.

﻿**Другие названия﻿**
 
Handle/Body (описатель/тело).

﻿**Применимость﻿**
 
Основные условия для применения паттерна мост:
* требуется избежать постоянной привязки абстракции к реализации. Так, например, бывает, когда реализация должна выбираться во время выполнения программы;
* и абстракции, и реализации должны расширяться новыми подклассами. В таком случае паттерн мост позволяет комбинировать разные абстракции и реализации и изменять их независимо;
* изменения в реализации абстракции не должны отражаться на клиентах, то есть клиентский код не должен перекомпилироваться;
* (только для C++) требуется полностью скрыть от клиентов реализацию абстракции. В C++ представление класса видимо через его интерфейс;
* число классов стремительно разрастается, как на первой диаграмме из раздела «Мотивация». Это признак того, что иерархию следует разделить на две части. Для таких иерархий классов Рамбо (Rumbaugh) использует термин «вложенные обобщения» [RBP+91];
* реализация должна совместно использоваться несколькими объектами (например, на базе подсчета ссылок), и этот факт должен быть скрыт от клиента. Простой пример — это разработанный Джеймсом Коплиеном класс String [Cop92], в котором разные объекты могут разделять одно и то же представление строки (StringRep).

﻿**Отношения﻿**
 
Объект Abstraction перенаправляет запросы клиента своему объекту Implementor.

﻿**Результаты﻿**
 
Результаты применения паттерна мост:
* отделение реализации от интерфейса. Реализация больше не имеет постоянной привязки к интерфейсу. Реализация абстракции может настраиваться во время выполнения. Объект может даже динамически изменять свою реализацию.
Разделение классов Abstraction и Implementor устраняет также зависимости от реализации, устанавливаемые на этапе компиляции. Чтобы изменить класс реализации, не обязательно перекомпилировать класс Abstraction и его клиентов. Это свойство особенно важно, если необходимо обеспечить двоичную совместимость между разными версиями библиотеки классов.
Кроме того, такое разделение облегчает разбиение системы на слои и тем самым позволяет улучшить ее структуру. Высокоуровневые части системы должны знать только о классах Abstraction и Implementor;
* повышение степени расширяемости. Иерархии классов Abstraction и Implementor могут расширяться независимо;
* сокрытие деталей реализации от клиентов. Клиентов можно изолировать от таких подробностей реализации, как совместное использование объектов класса Implementor и сопутствующего механизма подсчета ссылок.
