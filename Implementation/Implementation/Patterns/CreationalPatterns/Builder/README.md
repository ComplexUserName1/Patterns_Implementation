**Название и классификация паттерна﻿**

﻿**Строитель﻿** — паттерн, порождающий объекты.
 
﻿**Назначение﻿**

Отделяет конструирование сложного объекта от его представления, так что в результате одного и того же процесса конструирования могут получаться разные представления.

﻿**Применимость﻿**

Основные условия для применения паттерна строитель:
* алгоритм создания сложного объекта не должен зависеть от того, из каких частей состоит объект и как они стыкуются между собой;
* процесс конструирования должен обеспечивать различные представления конструируемого объекта.

Отношения

* клиент создает объект-распорядитель Director и настраивает его нужным объектом-строителем Builder;
* распорядитель уведомляет строителя о том, что нужно построить очередную часть продукта;
* строитель обрабатывает запросы распорядителя и добавляет новые части к продукту;
* клиент забирает продукт у строителя.

Следующая схема взаимодействий иллюстрирует взаимоотношения строителя и распорядителя с клиентом.

![image](https://github.com/user-attachments/assets/61033a9b-a70e-468b-819e-c821771b48ef)

Результаты

Паттерн строитель:
* позволяет изменять внутреннее представление продукта. Объект Builder предоставляет распорядителю абстрактный интерфейс для конструирования продукта, за которым он может скрыть представление и внутреннюю структуру продукта, а также процесс его сборки. Поскольку продукт конструируется через абстрактный интерфейс, то для изменения внутреннего представления достаточно всего лишь определить новый вид строителя;
* изолирует код, реализующий конструирование и представление. Паттерн строитель улучшает модульность, инкапсулируя способ конструирования и представления сложного объекта. Клиентам ничего не надо знать о классах, определяющих внутреннюю структуру продукта; эти классы не входят в интерфейс строителя.
Каждый конкретный строитель ConcreteBuilder содержит весь код, необходимый для создания и сборки конкретного вида продукта. Код пишется только один раз, после чего разные распорядители могут использовать его повторно для построения вариантов продукта из одних и тех же частей. В примере с RTF-документом мы могли бы определить загрузчик для формата, отличного от RTF (скажем, SGMLReader), и воспользоваться теми же классами TextConverter для генерирования представлений SGML-документов в виде ASCII-текста, TeX-текста или текстового виджета;
* предоставляет более точный контроль над процессом конструирования. В отличие от порождающих паттернов, которые сразу конструируют весь объект целиком, строитель делает это шаг за шагом под управлением распорядителя. И лишь когда продукт завершен, распорядитель забирает его у строителя. Поэтому интерфейс строителя в большей степени отражает процесс конструирования продукта, нежели другие порождающие паттерны. Это позволяет обеспечить более тонкий контроль над процессом конструирования, а значит, и над внутренней структурой готового продукта.
