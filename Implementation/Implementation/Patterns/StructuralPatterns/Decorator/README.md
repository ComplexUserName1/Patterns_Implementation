**Примеры здесь немного противоречат изначальной цели создания репозитория, так как используется несколько паттернов(Плюс есть некоторые логические дыры). В нормальных условиях достаточно использовать имплементацию ЛИБО с абстрактным классом ЛИБО с интерфейсом.**

**В целом мой косяк, но я как-то увлёкся с написанием имплементации, так как когда читал оригинал банды четырёх мне ещё на том моменте очень сильно хотелось попробовать написать имплементацию на основе аттрибутов(хотя это плохое решение :)).**

**Название и классификация паттерна﻿**
 
﻿**Декоратор﻿** — паттерн, структурирующий объекты.
 
﻿**Назначение﻿**
 
Динамически добавляет объекту новые обязанности. Является гибкой альтернативой порождению подклассов с целью расширения функциональности.

﻿**Другие названия﻿**
 
Wrapper (обертка).

﻿**Применимость﻿**
 
Основные условия для применения паттерна декоратор:
* динамическое, прозрачное для клиентов добавление обязанностей объектам (не затрагивающее другие объекты);
* реализация обязанностей, которые могут быть сняты с объекта;
* расширение путем порождения подклассов по каким-то причинам неудобно или невозможно. Иногда приходится реализовывать много независимых расширений, так что порождение подклассов для поддержки всех возможных комбинаций приведет к стремительному росту их числа. В других случаях определение класса может быть скрыто или почему-либо еще недоступно, так что породить от него подкласс нельзя.

﻿**Отношения﻿**
 
Decorator переадресует запросы объекту Component. Может выполнять и дополнительные операции до и после переадресации.

﻿**Результаты﻿**
 
У паттерна декоратор есть, по крайней мере, два плюса и два минуса:
* большая гибкость, нежели у статического наследования. Паттерн декоратор позволяет более гибко добавлять объекту новые обязанности, чем было бы возможно в случае статического (множественного) наследования. Декоратор может добавлять и удалять обязанности во время выполнения программы. С другой стороны, при использовании наследования требуется создавать новый класс для каждой дополнительной обязанности (например, BorderedScrollableTextView, BorderedTextView), что ведет к увеличению числа классов и, как следствие, к возрастанию сложности системы. Кроме того, применение нескольких декораторов к одному компоненту позволяет формировать произвольные комбинации обязанностей.
Декораторы также позволяют легко добавить одно и то же свойство дважды. Например, чтобы окружить объект TextView двойной рамкой, нужно просто добавить два декоратора BorderDecorators. Двойное наследование классу Border в лучшем случае чревато ошибками;
* позволяет избежать перегруженных функциями классов на верхних уровнях иерархии. Декоратор разрешает добавлять новые обязанности по мере необходимости. Вместо того чтобы пытаться поддержать все мыслимые возможности в одном сложном, допускающем разностороннюю настройку классе, вы можете определить простой класс и постепенно наращивать его функциональность с помощью декораторов. В результате приложение уже не перегружается неиспользуемыми функциями. Нетрудно также определять новые виды декораторов независимо от классов, которые они расширяют, даже если первоначально такие расширения не планировались. При расширении же сложного класса обычно приходится вникать в детали, не имеющие отношения к добавляемой функции;
* декоратор и его компонент не идентичны. Декоратор действует как прозрачное обрамление. Но декорированный компонент все же не идентичен исходному. При использовании декораторов это следует иметь в виду;
* множество мелких объектов. При использовании в проекте паттерна декоратор нередко формируется система, составленная из большого числа мелких объектов, похожих друг на друга. Такие объекты различаются только способом взаимосвязи, а не классом и не значениями своих внутренних переменных. Хотя такие системы легко настраиваются проектировщиком, хорошо разбирающимся в их строении, изучать и отлаживать их очень тяжело.
