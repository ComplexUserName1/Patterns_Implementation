**Название и классификация паттерна﻿**
 
﻿**Шаблонный метод﻿** — паттерн поведения классов.
 
﻿**Назначение﻿**
 
Шаблонный метод определяет основу алгоритма и позволяет подклассам переопределить некоторые шаги алгоритма, не изменяя его структуру в целом.

﻿**Применимость﻿**
 
Основные условия для применения паттерна шаблонный метод:
* однократное использование инвариантных частей алгоритма, при этом реализация изменяющегося поведения остается на усмотрение подклассов;
* необходимость вычленить и локализовать в одном классе поведение, общее для всех подклассов, чтобы избежать дублирования кода. Это хороший пример техники «вынесения за скобки с целью обобщения», описанной в работе Уильяма Опдайка (William Opdyke) и Ральфа Джонсона (Ralph Johnson) [OJ93]. Сначала выявляются различия в существующем коде, которые затем выносятся в отдельные операции. В конечном итоге различающиеся фрагменты кода заменяются шаблонным методом, из которого вызываются новые операции;
* управление расширениями подклассов. Шаблонный метод можно определить так, что он будет вызывать операции-зацепки (hooks) — см. раздел «Результаты» — в определенных точках, разрешив тем самым расширение только в этих точках.

﻿**Отношения﻿**
 
ConcreteClass предполагает, что инвариантные шаги алгоритма будут выполняться в AbstractClass.

﻿**Результаты﻿**
 
Шаблонные методы — один из фундаментальных приемов повторного использования кода. Они играют особенно важную роль в библиотеках классов, поскольку предоставляют возможность вынести общее поведение в библиотечные классы.

Шаблонные методы приводят к инвертированной структуре кода, которую иногда называют принципом Голливуда, подразумевая часто употребляемую в этой киноимперии фразу «Не звоните нам, мы сами вам позвоним» [Swe85]. В данном случае это означает, что родительский класс вызывает операции подкласса, а не наоборот.

Шаблонные методы вызывают операции следующих видов:
* конкретные операции (либо из класса ConcreteClass, либо из классов клиента);
* конкретные операции из класса AbstractClass (то есть операции, полезные всем подклассам);
* примитивные операции (то есть абстрактные операции);
* фабричные методы (см. паттерн фабричный метод (135));
* операции-зацепки (hook operations), реализующие поведение по умолчанию, которое может быть расширено в подклассах. Часто такая операция по умолчанию не делает ничего.

Важно, чтобы в шаблонном методе четко различались операции-зацепки (которые можно замещать) и абстрактные операции (которые нужно замещать). Чтобы повторно использовать абстрактный класс с максимальной эффективностью, авторы подклассов должны понимать, какие операции предназначены для замещения.

Подкласс может расширить поведение некоторой операции, заместив ее и явно вызвав эту операцию из родительского класса:

```
void DerivedClass::Operation () {
  // Расширенное поведение DerivedClass
  ParentClass::Operation();
}
```

К сожалению, очень легко забыть о необходимости вызывать унаследованную операцию. Такую операцию можно трансформировать в шаблонный метод, чтобы предоставить родителю контроль над тем, как подклассы расширяют его. Идея в том, чтобы вызывать операцию-зацепку из шаблонного метода в родительском классе. Тогда подклассы смогут переопределить именно эту операцию:

```
void ParentClass::Operation () {
  // Поведение ParentClass
  HookOperation();
}
```

В родительском классе ParentClass операция HookOperation не делает ничего:

```
void ParentClass::HookOperation () { }
```

Подклассы переопределяют HookOperation, чтобы расширить свое поведение:

```
void DerivedClass::HookOperation () {
  // Расширение в производном классе
}
```
