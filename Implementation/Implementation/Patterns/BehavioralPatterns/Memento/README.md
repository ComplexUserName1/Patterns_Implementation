**Так как в C# нет такого понятия как friend-классы как в C++, то пришлось подумать над обходом данной ситуации.**
**Но мне кажется пример в любом случае хороший получился и хорошо показывает суть паттерна.**

**Название и классификация паттерна﻿**
 
﻿**Хранитель﻿** — паттерн поведения объектов.
 
﻿**Назначение﻿**
 
Не нарушая инкапсуляции, фиксирует и выносит за пределы объекта его внутреннее состояние, так чтобы позднее можно было восстановить в нем объект.

﻿**Другие названия﻿**
 
Token (лексема).

﻿**Применимость﻿**
 
Основные условия для применения паттерна хранитель:
* необходимость сохранения снимка состояния объекта (или его части), чтобы впоследствии объект можно было восстановить в том же состоянии, и
* прямой интерфейс для получения этого состояния привел бы к раскрытию подробностей реализации и нарушению инкапсуляции объекта.

﻿**Отношения﻿**
 
* посыльный запрашивает хранитель у хозяина, некоторое время держит его у себя, а затем возвращает хозяину, как показано на следующей диаграмме взаимодействий.![image](https://github.com/user-attachments/assets/da477efe-b287-470b-b886-66874bafa2bb)Иногда этого не происходит, так как последнему не нужно восстанавливать прежнее состояние;
* хранители пассивны. Только хозяин, создавший хранитель, имеет доступ к информации о состоянии.

﻿**Результаты﻿**
 
Основные достоинства и недостатки паттерна хранитель:
* сохранение границ инкапсуляции. Хранитель позволяет избежать раскрытия информации, которой должен распоряжаться только хозяин, но которую тем не менее необходимо хранить вне последнего. Этот паттерн изолирует объекты от потенциально сложного внутреннего устройства хозяина, не изменяя границы инкапсуляции;
* упрощение структуры хозяина. При других вариантах дизайна, сохраняющего границы инкапсуляции, хозяин хранит внутри себя версии внутреннего состояния, которое запрашивали клиенты. Таким образом, вся ответственность за управление памятью лежит на хозяине. При перекладывании заботы о запрошенном состоянии на клиентов упрощается структура хозяина, а клиентам дается возможность не информировать хозяина о том, что они закончили работу;
* потенциальные затраты при использовании хранителей. С хранителями могут быть связаны заметные затраты, если хозяин должен копировать большой объем информации для сохранения хранителя в памяти, или если клиенты создают и возвращают хранители достаточно часто. Если затраты на инкапсуляцию и восстановление состояния хозяина велики, то этот паттерн не всегда подходит (см. также обсуждение инкрементности в разделе «Реализация»);
* определение «узкого» и «широкого» интерфейсов. В некоторых языках сложно гарантировать, что только хозяин может получить доступ к состоянию хранителя;
* скрытая плата за содержание хранителя. Посыльный отвечает за удаление хранителя, однако не располагает информацией о том, какой объем информации о состоянии скрыт в нем. Следовательно, нетребовательный к ресурсам посыльный может расходовать очень много памяти при работе с хранителем.
